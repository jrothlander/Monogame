# Introduction 

### Course Expectations

If you do not have a grasp on the basics of C#, I recommend you start with another course. Come back here once you have a decent understanding of the basics of C#. If this describes you, I’ve included a section in the appendix for prerequisite courses and book reviews that will give you some ideas and a few recommendations on where to start. It should not take you long to work through the basics and there are significant resources available to help you. It is simply beyond the scope of this text to cover a C# introduction.

I have developed this text as a textbook for a game development course. I have made every effort to have the text stand on its own and separate from the course. It is intended to serve as a reference that you can return to again and again, as you need a refresher and need to look up details you may have forgotten or concepts you are struggling with and need to reenforce. I recommend you download the source so you can work through the chapters and can experiment with the code as it is being discussed. I am unable to include the entirety of code in the text simply due to space constraints. And of course, if you prefer to have access to video lectures where I explain and demonstrate the code, you are always welcome to join the course at any time.   

If you are new to C# but have the basics down, you will be fine. Working through this text will be a great way to build your C# skills. If you are comfortable with and have already installed Visual Studio .Net, know how to create a new solution and project, are familiar with adding NuGet packages, and feel comfortable with creating classes, writing functions, the basics of object oriented programming, have been exposed to unit tests, and feel comfortable with the C# syntax, lists, arrays, properties, fields, variables, etc. then you should be fine. If you have the basic concepts down but still struggling with some of the details, this course should go a long way to help you reenforce these concepts.

### About the Author
> I want to give you a little background so you will have a feel for where I am coming from and how I have approach this subject, text, and the course.

I have been writing software since I was 11. Starting in the 6th grade back in early 80s, with BASIC on the Commodore64 (C64). I picked up dBaseIII and LISP in high school, landing my first job writing LISP for an engineering company when I was 18. Back in the early 90s, computer science was still pretty new in regards to a career path and a degree plan. Many universities were still working out the details. My counsolers struggled to advise me and the only people I knew that had jobs in software were doing data entry or writting printer drivers. I did know that wasn't want to I wanted to do. Unforunetly, I didn't have anyone to guide me at the time and didn't understand how to migrate a career path in software. I ended up majoring in biology, with the intent of using computer science in biological research. I later realized Electrical Engineering would be a better fit and I changed majors. But it was a litle too late, and after 5 years and 3 majors, I still had one more year to finish. I decided to take some time off and I ended up commiting the next 4-years to the US Air Force. Of course after my interview and a few tests, they decided to train me as software developer. Now for the sad part. About 30 years later, my son decided to attend the same university. As all families do, we were navigating the costs of college. While talking with the financial aid office, they asked... so why didn't you ever use your full-tuition scholarship when you here? Of course, my responce was... what full-tuition scholorship? I think you can figure out how the rest of that conversation went. They really did miss that I had a full tution scholorship. I still find it hard to believe.

After my military service, I spent a few years working contracts at the federal and state level and returning to college and invested anoter 7-years, for a total of 12-years full-time, finishing about 400 total semester hours and ended up with various undergraduate and graduate degrees, both computer science and biology. I do regret having not gone back and finished that electrical engineering degree. I did return to finish a post-grad program in AI/ML. After having worked on numerous AI projects over the years, I felt that I needed to step through a graduate level program of some sorts. I think I am an academic at heart and if my wife would let me, I’d probably go back full-time, work on a PhD, and teach at the univerity level.

It was sometime in 2000 that I first encountered a new C based language that Microsoft was working on and hadn’t yet named. I jumped on board when the betas came out in 2001, which brought me and my family to Austin, TX for the next 23 years. I was fortunate to have attended the launch of .Net in San Francisco on February 14th, 2002, and was an early adopter of .Net, having worked on several of the first .Net applications and having deployed a few into production by the summer of 2001. My team and I developed the very first .Net application that integrated with an IBM AS/400 (iSeries) and DB2 database. By integrated, I mean our .Net applications would execute RPG applications on the 400. Before .Net, we had to wrap AS/400 applications (written in RPG) with service APIs that emitted and consumed XML, allowing us to call them from VB6 COM objects embedded into HTML pages. This wasn’t too bad for simple a web application, but it could quickly get out of hand and turn into a mess for the larger enterprise level applications we were building. We called these wrappers, http-request-handlers and later this technique would become integral to .Net and named web services by Microsoft. With .Net Web Services and ASP.Net, .Net immediately solved so many problems for us that we adopted it the same day the betas were released. While all of this may not seem like a big deal today, in 2001 it was unheard of. 

Microsoft and a few partner companies such as Infragistics and Data Dynamics picked up that we were working on a few of these apps, which enabled me to do early partner projects, white papers, as well as gain access to early training. I was also able to present what we were doing at few conferences along the way. Since then, I have focused on C# and .Net, worked in R&D for about 10 years as a Chief R&D Architect, developing cross-language tools for .Net such as parsers, code generators, and re-platforming tools. I returned to the normal corporate grind in 2011 and did a few years of consulting for several top Fortune 500 companies (Whole Foods, URS, and DR Horton) as a senior .Net developer, and finally accepted a full-time position in 2013 where I remain today. With 30+ years of experience and 23+ in C#, I’ve had a great career so far. I think I was fortunate to get an early start and now I’ve taking some time to go back to where I started, having fun with games. 

I wanted to give you these details about my background, to give you some since of where I am coming from and my approach. I think I approach things more from an academic perspective because of my academic background. I am research and detail oriented, and try to provide references and resources for you to dig into the topics you are interested in. After 12-years of college, the one thing I think I have actually mastered, is how to break down and learn something new. Taking apart a text and digging into the details, I think that is a skillset many younger developers struggle with. For this course, I attacked 16 printed books and probably 30+ eBooks. When I say attacked, I mean read every word, marked up the book, and really take the book apart and dig into it. That is how I approached learning game development. What I have discovered along the way, that is what I want to share with you. 

I’ve always been fascinated with game development. But during the past few years, mostly due to the Covid lockdowns, I rekindled an interest in retro computers. I started with building my own 6502 computer, and later designed and built my own 8-bit computer, which lead to an interest in programming applications to run on them. I love the older games due to their exciting gameplay, which I believe is often lost in modern games. While I do enjoy the modern first-person shooter games, but I have never drawn to them like I am to the older arcade games like Pac-Man and Galaga. But more than just playing the games, understanding the development techniques used to design and build these games is fascinating and are great academic exercise to learn from. However, we don’t have to build them the same as they would have been in 1980s. No Assembly code here. Using C# and .Net Core along with MonoGame, we can create fantastic games with exiting game play and relatively easily and with a minimal learning curve.  

So, lets jump in. 

