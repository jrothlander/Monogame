# Introduction 

### Course Expectations

If you have a grasp on the basics of C#, I recommend you start with another course to get the basics under your belt. Come back here once you have a decent understanding of the basics of C#. If this describes you, I’ve included a section in the appendix for prerequisite courses and book reviews that will give you some ideas and a few recommendations on where to start. It should not take you long to work through the basics and there are significant resources available to help you. It is simply beyond the scope of this text to cover a C# introduction.

I have developed this text as a textbook for a game development course. I have made every effort to have the text stand on its own and separate from the course. It is intended to serve as a reference that you can return to again and again, as you need a refresher and need to look up details you may have forgotten or concepts you are struggling with, or areas you need to reenforce. I recommend you download the free course materials so you can work through the chapters and can experiment with the code as it is being discussed, as I am unable to include the entirety of code in the text simply due to space constraints. And of course, if you prefer to have access to video lectures where I explain and demonstrate the code, you are always welcome to join the course at any time.   

If you are new to C# but have the basics down, you will be fine. Working through this text will be a great way to build your C# skills. If you are comfortable with or have already installed Visual Studio .Net, know how to create a new solution and project, are familiar with adding NuGet packages, and feel comfortable with creating classes, writing functions, the basics of object oriented programming, have been exposed to unit tests, and feel comfortable with the C# syntax, lists, arrays, properties, fields, variables, etc. then you should be fine. If you have the basic concepts down but still struggling with some of the details, this course should go a long way to help you reenforce these concepts.

### About the Author
> I want to give you a little background so you will have a feel for where I am coming from and how I approach software, this text, and the course.

I have been writing software since I was 11. Starting in the 6th grade back in early 80s. I started with BASIC on the Commodore64 (C64) and picked up dBaseIII and LISP in high school, and landed my first job writing LISP for an engineering company when I was 18. That was a pretty early start in those days and I am grateful for having been introduced to software early on. 

Back in the early 90s, computer science was not a great degree plan. At least as far as an 18 year old kid was concerned. Most universities were still working out exactly what a software developer needed to know. The counsolers struggled to advise me and the only people I knew that had jobs in software, were doing data entry or writing printer drivers. Needless to say, that wasn't want to I wanted to do. Unforunetly, I didn't have anyone to guide me at the time and didn't understand how to migrate a career path in software. So, I decided to major in biology, with the intent of using computer science and biology in biological research. I later clued in and realized Electrical Engineering would be a better fit and I transferred majors. But after 5 years in college, they said it still had one more to finish and the stress of working and paying for school finally pushed me over the edge. I decided to pause and take some time off. I ended up commiting the next 4-years to the US Air Force, and of course after testing me, they decided they would train me as software developer. So, it worked out. But now for the sad part. About 30 years later, my son decided to attend the same university. As all families do, we were navigating the costs of college. While talking with the financial aid office, they asked... so why didn't you ever use your full-tuition scholarship when you here? Of course, my responce was... what full-tuition scholoship? I think you can figure out the rest of that conversation went. They really did missed that I had a full tution scholorship. I still find it hard to believe.

After my military service, I spent about 3 years as a contractor at the federal and state level. I ended up returning to college and investing anoter 7-years, for a total of 12-years full-time, finishing about 400 total semester hours and ended up with various undergraduate and graduate degrees, both computer science and biology. But unfortunately, I regret having not gone back and finishing that electrical engineering degree. I did completed a post-grad program in AI/ML, as I have been working on numerous projects in AI since about 2010 and felt that I needed to step through a graduate level program of some sorts. I think I am an academic at heart and if my wife would let me, I’d probably go back full-time and maybe teach at the univerity level.

It was sometime in 2000 that I first encountered a new C based language that Microsoft was working on and hadn’t yet named. I jumped on board when the betas came out in 2001, which brought me and my family to Austin, TX for the next 23 years. I was fortunate to have attended the launch of .Net in San Francisco on February 14th, 2002, and was an early adopter of .Net, having worked on several of the first .Net applications and having deployed a few into production by the summer of 2001. My team and I developed the very first .Net application that integrated with an IBM AS/400 (iSeries) and DB2 database. By integrated, I mean our .Net applications would execute RPG applications on the 400. Before .Net, we had to wrap AS/400 applications (written in RPG) with service APIs that emitted and consumed XML, allowing us to call them from VB6 COM objects embedded into HTML pages. This wasn’t too bad for simple a web application, but it could quickly get out of hand and turn into a mess for the larger enterprise level applications we were building. We called these wrappers, http-request-handlers and later this technique would become integral to .Net and named web services by Microsoft. With .Net Web Services and ASP.Net, .Net immediately solved so many problems for us that we adopted it the same day the betas were released. While all of this may not seem like a big deal today, in 2001 it was unheard of. 

Microsoft and a few partner companies such as Infragistics and Data Dynamics picked up that we were working on a few of these apps, which enabled me to do early partner projects, white papers, as well as gain access to early training. I was also able to present what we were doing at few conferences along the way. Since then, I have focused on C# and .Net, worked in R&D for about 10 years developing cross-language tools for .Net such as parsers, code generators, and re-platforming tools. But ultimately, returned to the normal corporate grind in 2011 and did a few years of consulting for several top Fortune 500 companies (Whole Foods, URS, and DR Horton) as a senior .Net developer, and finally accepted a full-time position in 2013 where I remain today. With 30+ years of experience and 23+ in C#, I’ve had a great career so far. I think I was fortunate to get an early start and now I’ve taking some time to go back to where I started, having fun with games. 

I wanted to give you some details about my background, to give you some since of where I am coming from and my approach. I think I approach things more from an academic perspective because of my academic background. I am research and detail oriented, and try to provide references and resources for you to dig into the topics you are interested in. After 12-years of college, the one thing I think I have actually mastered, is how to break down and learn something I do not know. Having the ability to take a text apart and dig into the details, I think that is a skillset many younger developers struggle with. For this course, I attacked 16 printed books and probably 30 eBooks. When I say attacked, I mean read every word, marked up the book, and really take the book apart. That is how I approached learning game development from scratch after 30-years in the career. 

I’ve always been fascinated with game development and lost that focus along the way. In the last few years, mostly due to the Covid lockdowns, I rekindled an interest in retro computers. I started with building my own 6502 computer, and later designed and built my own 8-bit computer, which lead to an interest in programming applications to run on them. I love the older games due to their exciting gameplay, which I believe is often lost in modern games. While I do enjoy the modern first-person shooting games, but I have never drawn to them like I am to the older arcade games like Pac-Man and Galaga. But more than just playing the games, understanding the development techniques used to design and build these games is fascinating and are great academic exercise to learn from. This is what I hope to share with you. 

However, we don’t have to build them the same as they would have been in 1980s. No Assembly code here. Using C# and .Net Core along with MonoGame, we can create fantastic games with exiting game play and relatively easily and with a minimal learning curve.  

So, lets jump in. 

### What if my goal is to be a 3D game developer? Is it worth the time to learn 2D? What about MonoGame?

2D and 3D game development skills are significantly different skillsets in many regards. However, I believe that everything you learn 2D game development will help you in 3D. Since we are using MonoGame for our game development framework, we will be implementing our own game engine. Make sure you understand what I just said. MonoGame is not a game engine, it is a framework to build a game engine. That means that we will not be using the MonoGame collision framework, because it does not exist, and we will be building our own. Sounds complicated right? It is not. Typically the collision functions for a retro style arcade game take up less than 5 lines of code.  Sure, you can go crazy and build much more complex systems, or use third party libraries if you feel that it is a better fit for your needs. But the point is that you don't have to. You have the flexibility to decide. Everything we will be working with will not require any math skills beyond simple trigonometry (using sin and cos) and some basic matrix algebra. If you need a review of those, we will go over all of the details.  

The other side of this question is if we should be using a game engine such as Unity or UnReal Engine. There are advantages and disadvantages. The major disadvantage with starting in 3D with an engine, is not taking them time to build a strong foundation, and not to mention having to carry along a massive game engine when you only need a small part of it for your game. Other disadvantages include things like the ever-changing licensing, fees, breaking API changes, and other issues that our out of your control but that effect your game. If you are interested in building retro style arcade games, I very much recommend that you avoid these engines simply because if your game goes viral, you will have to contend with a not of stress around liensing. You can completely avoid that by taking the time to build your own engine specifically designed for your game.   

Using MonoGame, our approach will be to simply build the game engine components we need. If you continue to 3D engines, having worked through your own engine components will go a long way to reenforce concepts that you will still need to understand. I personally would not want to be a 3D game developer that struggles with the basic concepts of 2D game development. I really want to encourage you to start with some simple 2D games and build up to more complex 2D, before moving to 3D. I think it is important to develop skills using 2D math, linear algebra, vector math, 2D animation, etc. as foundational skills. But not have to contend with learning any given engine.  

I mention this because I suspect some of you will be more interested in 3D and will be wondering if you need to waste your time working in 2D. The answer is yes. It is my opinion that starting in 2D and moving to 3D is a great way to build a foundation. Jumping directly into 3D engines is not necessarily a bad idea, and you can build 2D games using a 3D engine. But I think starting in 2D game framework like MonoGame is simply a better approach. A good way to see what I mean, let's take a quick look at various game dev books on Amazon to see what sort of topics they are discussing. 

The first book returnd from a search for "C++ Game Development" is _Game Development Patterns with Unreal Engine 5_, by Butler and Oliver (2024). Reviewing the table of contents, we can review the topics covered. Of course any book on game dev is going to start off with some history and background, as well as some basic software dev concepts. Skipping forward a few chapters past installation, setup, and intro to C++, we get into S.O.L.I.D  principles, interfaces, delegates, events, and more specifically design patterns such as observer, signleton, command, and state. All great stuff. They also devote a chapter to understanding game time, ticks, the game clock, decoupling, object pooling, and state machines. If you jump to the second book on the list, _Learning C# by Developing Games with Unity_, 7th edition by Harrison Ferrone (2022) and skip over the first five chapters devoted to introductary details, they focus on player movement, cameras, physics, and collisions. Then jumping, projectiles, game managers, and AI (not to be confused with data science and machine learning) with sections on enemy agaents patterns, movements, and mechanics. Again, all great stuff. 

All of these topics are topics we will be covering in 2D, but without having to teach you Unity or Unreal Engine. So, I hope you can see my point here. Do you want to learn Unity or Unreal Engine to start? Or do you want to learn core concepts of game development as a foundation for everything else you do going forward? I personally feel like MonoGame is more about learning game development where Unity and Unreal are more about Unity and Unreal. But don't get me wrong. That is 100% not a bad thing. It just depends on your desire, goals, the skills you want to learn. If you want a foundation in game dev that is outside of any single engine, then starting with MonoGame is a great way to learn.
